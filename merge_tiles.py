import argparse
import json
import os
from typing import Tuple

import numpy as np
import rasterio
from affine import Affine
from PIL import Image
from rasterio.crs import CRS
from rasterio.windows import Window


def read_tile(path: str) -> np.ndarray:
    """Load a PNG tile and return an array shaped (bands, rows, cols)."""
    with Image.open(path) as img:
        array = np.array(img)

    if array.ndim == 2:
        return array[np.newaxis, ...]

    return np.transpose(array, (2, 0, 1))


def ensure_output_directory(output_path: str) -> None:
    directory = os.path.dirname(output_path)
    if directory:
        os.makedirs(directory, exist_ok=True)


def load_metadata(metadata_path: str) -> dict:
    with open(metadata_path, "r", encoding="utf-8") as src:
        return json.load(src)


def determine_canvas_size(index: dict) -> Tuple[int, int]:
    width = index.get("source_width")
    height = index.get("source_height")
    tiles = index.get("tiles") or []

    if width is not None and height is not None:
        return int(width), int(height)

    width = max(record["x_offset"] + record["width"] for record in tiles)
    height = max(record["y_offset"] + record["height"] for record in tiles)
    return int(width), int(height)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Merge tiles generated by tile_all.py into a single GeoTIFF.",
    )
    parser.add_argument(
        "--tiles_dir",
        required=True,
        help="Directory containing PNG tiles and metadata files.",
    )
    parser.add_argument(
        "--output",
        required=True,
        help="Path for the merged GeoTIFF output.",
    )
    parser.add_argument(
        "--metadata",
        help="Path to tiles_index.json (defaults to <tiles_dir>/tiles_index.json).",
    )
    args = parser.parse_args()

    tiles_dir = os.path.abspath(args.tiles_dir)
    metadata_path = args.metadata or os.path.join(tiles_dir, "tiles_index.json")

    if not os.path.isfile(metadata_path):
        raise FileNotFoundError(f"Metadata file not found: {metadata_path}")

    index = load_metadata(metadata_path)
    tile_records = index.get("tiles") or []
    if not tile_records:
        raise ValueError("No tile entries found in metadata; nothing to merge.")

    transform_vals = index.get("transform_gdal")
    if not transform_vals:
        raise ValueError("Metadata missing transform_gdal values.")
    transform = Affine.from_gdal(*transform_vals)

    crs_wkt = index.get("crs_wkt")
    crs = CRS.from_wkt(crs_wkt) if crs_wkt else None

    canvas_width, canvas_height = determine_canvas_size(index)

    tile_records = sorted(tile_records, key=lambda r: (r["y_offset"], r["x_offset"]))
    first_tile_path = os.path.join(tiles_dir, tile_records[0]["png"])
    first_tile = read_tile(first_tile_path)
    band_count = first_tile.shape[0]
    dtype = first_tile.dtype

    profile = {
        "driver": "GTiff",
        "width": canvas_width,
        "height": canvas_height,
        "count": band_count,
        "dtype": dtype,
        "transform": transform,
    }

    if crs:
        profile["crs"] = crs

    if band_count == 1:
        profile["photometric"] = "MINISBLACK"
    elif band_count == 3:
        profile["photometric"] = "RGB"
    elif band_count == 4:
        profile["photometric"] = "RGBA"

    ensure_output_directory(args.output)

    with rasterio.open(args.output, "w", **profile) as dst:
        for record in tile_records:
            tile_path = os.path.join(tiles_dir, record["png"])
            tile_array = read_tile(tile_path)

            if tile_array.shape[0] != band_count:
                raise ValueError(
                    f"Tile {record['png']} band mismatch: expected {band_count}, got {tile_array.shape[0]}"
                )

            if tile_array.dtype != dtype:
                tile_array = tile_array.astype(dtype)

            window = Window(
                int(record["x_offset"]),
                int(record["y_offset"]),
                int(record["width"]),
                int(record["height"]),
            )
            dst.write(tile_array, window=window)

    print(f"Merged {len(tile_records)} tiles into {args.output}")

if __name__ == "__main__":
    main()